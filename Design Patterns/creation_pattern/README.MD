# ‚öôÔ∏è Creation Pattern
Os padr√µes criacionais fornecem v√°rios mecanismos de cria√ß√£o de objetos, que aumentam a flexibilidade e reutiliza√ß√£o de c√≥digo j√° existente. S√£o eles:

- Factory Method
O Factory Method √© um padr√£o criacional de projeto que fornece uma interface para criar objetos em uma superclasse, mas permite que as subclasses alterem o tipo de objetos que ser√£o criados.

- Abstract Factory
Permite que voc√™ produza fam√≠lia de objetos relacionados sem ter que especificar suas classes concretas

- Builder 
Permite construir objetos complexos passo a passo. O padr√£o permite produzir diferentes tipos e representa√ß√µes de um objeto usando o mesmo c√≥digo de constru√ß√£o.

- Singleton
Permite a voc√™ garantir que uma classe tem apenas uma inst√¢ncia, enquanto prov√™ um ponto de acesso global para a inst√¢ncia.


##  üîó Fontes
- [Visite o Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/creational-patterns)
- [DevMedia](https://www.devmedia.com.br/introducao-aos-padroes-criacionais-abstract-factory-factory-method-prototype-e-singleton/21249)
- [Medium](https://medium.com/@jonesroberto/desing-patterns-parte-2-2a61878846d)




# Como funciona o Factory Method

## Partes do c√≥digo Conceito em Java Script

Vamos usar como exemplo, um sistema de notifica√ß√£o em que utiliza-se tr√™s tipos de notifica√ß√µes: SMS, Email e Push.

- Sistema de Notifica√ß√£o

/
  
    
    
    //Interface para os produtos(Notifica√ß√µes) classe abstrata
    
    class Notification{
      constructor(){
        if(new.target === Notification){
            throw new Error("Esta √© uma classe abstrata e n√£o pode ser instanciada diretamente!")
        }
    }
    
    send(message) {
      throw new Error("Este m√©todo deve ser sobrescrito!");
    }
    }

    //Implementa√ß√µes concretas dos produtos - classes concretas
    class EmailNotification extends Notification{
        send(message){
            console.log(`Notifica√ß√£o via Email. Mensagem:${message}`)
        }
    }
    class SMSNotification extends Notification{
        send(message){
            console.log(`Notifica√ß√£o via SMS. Mensagem: ${message}`)
        }
    }
    class PushNotification extends Notification{
        send(message){
            console.log(`Notifca√ß√£o via Push. Mensagem: ${message}`)
        }
    }
    //M√©todo Factory
    class NotificationFactory{
        static createNotification(type){
            if(typeof type === "string" && type !== null){
                switch(type.toLowerCase()){
                    case 'email':
                    return new EmailNotification()
                    case 'sms':
                    return new SMSNotification()
                    case 'push':
                    return new PushNotification()
                    default:
                    throw new Error(`Tipo de notifica√ß√£o desconhecido.`)
                }
            }else{
                throw new Error("Tipo inv√°lido de notifica√ß√£o.")
            }
        }
    }
    //Cliente que usa a f√°brica de notifica√ß√µes
    class NotificationService{
        constructor(factory){
            this.factory = factory
        }
        sendNotification(type,message){
            const notification = this.factory.createNotification(type)
            notification.send(message)
        }
    }
    //Uso do Factory Method em um contexto maix complexo
    const notificationService = new NotificationService(NotificationFactory)

    notificationService.sendNotication('email', 'Mensagem de email')
    no
    notifcationService.sendNotification('sms', 'Mensagem de SMS')
    notificationService.sendNotification('push', 'Mensagem Push.')
  
  
 
 
    
  
