# ‚öôÔ∏è Creation Pattern
Os padr√µes criacionais fornecem v√°rios mecanismos de cria√ß√£o de objetos, que aumentam a flexibilidade e reutiliza√ß√£o de c√≥digo j√° existente. S√£o eles:

- Factory Method
O Factory Method √© um padr√£o criacional de projeto que fornece uma interface para criar objetos em uma superclasse, mas permite que as subclasses alterem o tipo de objetos que ser√£o criados.

- Abstract Factory
Permite que voc√™ produza fam√≠lia de objetos relacionados sem ter que especificar suas classes concretas

- Builder 
Permite construir objetos complexos passo a passo. O padr√£o permite produzir diferentes tipos e representa√ß√µes de um objeto usando o mesmo c√≥digo de constru√ß√£o.

- Singleton
Permite a voc√™ garantir que uma classe tem apenas uma inst√¢ncia, enquanto prov√™ um ponto de acesso global para a inst√¢ncia.


##  üîó Fontes
- [Visite o Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/creational-patterns)
- [DevMedia](https://www.devmedia.com.br/introducao-aos-padroes-criacionais-abstract-factory-factory-method-prototype-e-singleton/21249)
- [Medium](https://medium.com/@jonesroberto/desing-patterns-parte-2-2a61878846d)




# Como funciona o Factory Method

## Partes do c√≥digo Conceito em Java Script

Vamos usar como exemplo, um sistema de notifica√ß√£o em que utiliza-se tr√™s tipos de notifica√ß√µes: SMS, Email e Push.

- Sistema de Notifica√ß√£o

/
  
    
    
    //Interface para os produtos(Notifica√ß√µes) classe abstrata
    
    class Notification{
      constructor(){
        if(new.target === Notification){
            throw new Error("Esta √© uma classe abstrata e n√£o pode ser instanciada diretamente!")
        }
    }
    
    send(message) {
      throw new Error("Este m√©todo deve ser sobrescrito!");
    }
    }

    //Implementa√ß√µes concretas dos produtos - classes concretas
    class EmailNotification extends Notification{
        send(message){
            console.log(`Notifica√ß√£o via Email. Mensagem:${message}`)
        }
    }
    class SMSNotification extends Notification{
        send(message){
            console.log(`Notifica√ß√£o via SMS. Mensagem: ${message}`)
        }
    }
    class PushNotification extends Notification{
        send(message){
            console.log(`Notifca√ß√£o via Push. Mensagem: ${message}`)
        }
    }
    //M√©todo Factory
    class NotificationFactory{
        static createNotification(type){
            if(typeof type === "string" && type !== null){
                switch(type.toLowerCase()){
                    case 'email':
                    return new EmailNotification()
                    case 'sms':
                    return new SMSNotification()
                    case 'push':
                    return new PushNotification()
                    default:
                    throw new Error(`Tipo de notifica√ß√£o desconhecido.`)
                }
            }else{
                throw new Error("Tipo inv√°lido de notifica√ß√£o.")
            }
        }
    }
    //Cliente que usa a f√°brica de notifica√ß√µes
    class NotificationService{
        constructor(factory){
            this.factory = factory
        }
        sendNotification(type,message){
            const notification = this.factory.createNotification(type)
            notification.send(message)
        }
    }
    //Uso do Factory Method em um contexto maix complexo
    const notificationService = new NotificationService(NotificationFactory)

    notificationService.sendNotication('email', 'Mensagem de email')
    no
    notifcationService.sendNotification('sms', 'Mensagem de SMS')
    notificationService.sendNotification('push', 'Mensagem Push.')
  
  
 # Quando implementar o Factory Method

- Use quando desejar economizar recursos do sistema reutilizando objetos existentes em vez de recri√°-los sempre.
- Use quando desejar fornecer aos usu√°rios da sua biblioteca ou framework uma maneira de estender seus componentes internos.
- Use quando n√£o souber de antem√£o os tipos e depend√™ncias exatas dos objetos com os quais seu c√≥digo deve funcionar.
 
# Como implementar

Fa√ßa todos os produtos implementarem a mesma interface. Essa interface deve declarar m√©todos que fazem sentido em todos os produtos.

Adicione um m√©todo f√°brica vazio dentro da classe criadora. O tipo de retorno do m√©todo deve corresponder √† interface comum do produto.

No c√≥digo da classe criadora, encontre todas as refer√™ncias aos construtores de produtos. Um por um, substitua-os por chamadas ao m√©todo f√°brica, enquanto extrai o c√≥digo de cria√ß√£o do produto para o m√©todo f√°brica.

Pode ser necess√°rio adicionar um par√¢metro tempor√°rio ao m√©todo f√°brica para controlar o tipo de produto retornado.

Neste ponto, o c√≥digo do m√©todo f√°brica pode parecer bastante feio. Pode ter um grande operador switch que escolhe qual classe de produto instanciar. Mas n√£o se preocupe, resolveremos isso em breve.

Agora, crie um conjunto de subclasses criadoras para cada tipo de produto listado no m√©todo f√°brica. Sobrescreva o m√©todo f√°brica nas subclasses e extraia os peda√ßos apropriados do c√≥digo de constru√ß√£o do m√©todo base.

Se houver muitos tipos de produtos e n√£o fizer sentido criar subclasses para todos eles, voc√™ poder√° reutilizar o par√¢metro de controle da classe base nas subclasses.

Por exemplo, imagine que voc√™ tenha a seguinte hierarquia de classes: a classe base Correio com algumas subclasses: CorreioA√©reo e CorreioTerrestre; as classes Transporte s√£o Avi√£o, Caminh√£o e Trem. Enquanto a classe CorreioA√©reo usa apenas objetos Avi√£o, o CorreioTerrestre pode funcionar com os objetos Caminh√£o e Trem. Voc√™ pode criar uma nova subclasse (por exemplo, CorreioFerrovi√°rio) para lidar com os dois casos, mas h√° outra op√ß√£o. O c√≥digo do cliente pode passar um argumento para o m√©todo f√°brica da classe CorreioTerrestre para controlar qual produto ele deseja receber.

Se, ap√≥s todas as extra√ß√µes, o m√©todo f√°brica base ficar vazio, voc√™ poder√° torn√°-lo abstrato. Se sobrar algo, voc√™ pode tornar isso em um comportamento padr√£o do m√©todo.

  
